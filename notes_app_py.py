# -*- coding: utf-8 -*-
"""notes_app.py

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1XpVA9pbBIZ5q9QI5tdOehMaEFh6sgXCx
"""

from datetime import datetime
from typing import List, Optional
import os

# to format notes
class Note:
    def __init__(self, note_id: int, content : str, timestamp : datetime):
        self.note_id = note_id
        self.content = content
        self.timestamp = timestamp

    def format_note(self) -> str:
        return (
            f"ID: {self.note_id}\n"
            f"Time: {self.timestamp}\n"
            f"Content: {self.content}\n"
            f"{'-' * 30}\n"
        )

    def matches_keyword(self, keyword : str) -> bool:
        return keyword.lower() in self.content.lower()


# user class to contron Username and password
class User:
    def __init__(self, username: str, password : str) :
        self.username = username
        self.password = password
        self.notes_file = f'{username}_notes.txt'

    def verify_password(self, input_password : str) -> bool:
        return self.password == input_password

    def get_notes_file(self) -> str:
        return self.notes_file


# validator class to validate credentials
class Validator:
    @staticmethod
    def validate_username(username : str) -> bool:
        return username.strip() != ""

    @staticmethod
    def validate_password(password: str) -> bool:
        return len(password) >= 4

    @staticmethod
    def validate_note_content(content: str) -> bool:
        return content.strip() != ""

    @staticmethod
    def validate_note_id(note_id: int) -> bool:
        return note_id > 0


# FileManager class to read, write, append file
class FileManager:
    def __init__(self, file_path: str):
        self.file_path = file_path

    def read_file(self) -> str:
        if not os.path.exists(self.file_path) :
            return ""
        with open(self.file_path, 'r') as f:
            return f.read()

    def write_file(self, data: str) -> None:
        with open(self.file_path, 'w') as f:
            f.write(data)

    def append_file(self, data: str) -> None:
        with open(self.file_path, 'a') as f:
            f.write(data)

    def file_exists(self) -> bool:
        return os.path.exists(self.file_path)


# authentication manager
class AuthManager:
    def __init__(self, user_file: str, logger):
        self.user_file = os.path.abspath(user_file)
        self.logger = logger

    def register_user(self, username: str, password: str) -> bool:
        if not Validator.validate_username(username):
            print('Invalid Username.')
            return False

        if not Validator.validate_password(password):
            print('password must be at least 4 characters.')
            return False

        if self.user_exists(username):
            print('User allready exists.')
            return False

        try:
            with open(self.user_file, 'a') as f:
                f.write(f"{username}:{password}\n")
                print('Registration Sucessfull.')
                return True
        except Exception as e:
            self.logger.log_error(str(e))
            return False

    def login_user(self, username : str, password : str) -> Optional[User]:
        try:
            if not os.path.exists(self.user_file):
                print('No registration found.')
                return None

            with open(self.user_file, 'r') as f:
                for line in f:
                    stored_username, stored_password = line.strip().split(':')
                    if stored_username == username and stored_password == password:
                        print('Login Sucessfull.')
                        return User(username, password)
                print('Invalid credentials.')
                return None
        except Exception as e:
            self.logger.log_error(str(e))
            return None

    def user_exists(self, username: str) -> bool:
        if not os.path.exists(self.user_file):
            return False
        with open(self.user_file, 'r') as f:
            for line in f:
                if line.split(':')[0] == username:
                    return True
        return False


# NotesManager class
class NotesManager:
    def __init__(self, user: User, logger):
        self.user = user
        self.file_manager = FileManager(user.get_notes_file())
        self.logger = logger

    def generate_note_id(self) -> int:
        raw_data = self.file_manager.read_file()
        if not raw_data:
            return 1
        notes = raw_data.strip().split('-' * 30)
        return len([n for n in notes if n.strip()])+1

    def add_note(self, content: str) -> None:
        if not Validator.validate_note_content(content):
            print('Note cannot be empty.')
            return
        note_id = self.generate_note_id()
        note = Note(note_id, content, datetime.now())
        try:
            self.file_manager.append_file(note.format_note())
            print('Notes added successfully.')
        except Exception as e:
            self.logger.log_error(str(e))

    def view_notes(self) -> List[Note]:
        raw_data = self.file_manager.read_file()
        if not raw_data:
            print('No notes found.')
            return
        print('Your notes: ')
        print(raw_data)


    def delete_note(self, note_id: int) -> bool:
        if not Validator.validate_note_id(note_id):
            print('Invalid note id.')
            return
        raw_data = self.file_manager.read_file()
        notes = raw_data.strip().split('-' * 30)
        updated_notes = []
        deleted = False

        for notes_in in notes:
            if f'ID: {note_id}' in notes_in:
                deleted = True
                continue
            if notes_in.strip():
                updated_notes.append(notes_in.strop()+'\n')
        if deleted:
            self.file_manager.write_file(''.join(updated_notes))
            print('Notes deleted successfully.')
        else:
            print('Note not found.')


    def search_notes(self, keyword: str) -> List[Note]:
        raw_data = self.file_manager.read_file()
        if not raw_data:
            print('No notes found.')
            return
        notes = raw_data.strip().split('-' * 30)
        found = False

        for note_in in notes:
            if keyword.lower() in note_in.lower():
                print(note_in)
                print('-' * 30)
                found = True
        if not found:
            print('no matching notes found.')

# logger class
class Logger:
    def __init__(self, log_file : str = 'error.log'):
        self.log_file = log_file

    def log_error(self, message: str) -> str:
        with open(self.log_file, 'a') as f:
            f.write(f'[Error]{datetime.now()} - {message}\n')

    def log_info(self, message: str) -> None:
        with open(self.log_file, 'a') as f:
            f.write(f'[INFO]{datetime.now()} - {message}\n')


# Main notes app
class NotesApp:
    def __init__(self):
        self.logger = Logger()
        self.auth_manager = AuthManager('users.txt', self.logger)
        self.current_user : Optional[User] = None
        self.notes_manager : Optional[NotesManager] = None

    def start(self) -> None:
        while True:
            print('1. Register')
            print('2. Login')
            print('3. Exit')

            try:
                user_choice = int(input('Enter your choice: '))
                if user_choice == 1:
                    username = input('Enter your username: ')
                    password = input('Enter your Password: ')
                    self.auth_manager.register_user(username, password)
                elif user_choice == 2:
                    username = input('Enter your username: ')
                    password = input('Enter your Password: ')
                    user = self.auth_manager.login_user(username, password)
                    if user:
                        self.current_user = user
                        self.notes_manager = NotesManager(user, self.logger)
                        self.dashboard()
                elif user_choice == 3:
                    print('Goodbye! have a nice day.')
                    break
                else:
                    print('Invalid choice, please choice the correct one.')
            except ValueError:
                print('please enter integer value')
            except Exception as e:
                self.logger.log_error(str(e))


    def dashboard(self):
        while True:
            print('1. Add Note')
            print('2. View notes')
            print('3. Delete note')
            print('4. Search notes')
            print('5. Logout')

            try:
                user_choice = int(input('Enter your choice: '))
                if user_choice == 1:
                    content = input('Enter new content: ')
                    self.notes_manager.add_note(content)
                elif user_choice == 2:
                    self.notes_manager.view_notes()
                elif user_choice == 3:
                    note_id = int(input('Enter note ID: '))
                    self.notes_manager.delete_note(note_id)
                elif user_choice == 4:
                    keyword = input('Enter keyword to search: ')
                    self.notes_manager.search_notes(keyword)
                elif user_choice == 5:
                    print('Logged Out')
                    self.current_user = None
                    break
                else:
                    print('Invalid choice.')
            except ValueError:
                print('please enter integer value.')
            except Exception as e:
                print(f"Unexpected error: {e}")
                self.logger.log_error(str(e))

if __name__ == '__main__' :
    app = NotesApp()
    app.start()